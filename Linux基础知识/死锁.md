<!-- GFM-TOC -->
* [必要条件](#必要条件)
* [处理方法](#处理方法)
* [死锁检测与死锁恢复](#死锁检测与死锁恢复)
    * [1. 进程拥有一个资源](#1-进程拥有一个资源)
    * [2. 进程拥有多个资源](#2-进程拥有多个资源)
    * [3. 死锁恢复](#3-死锁恢复)
<!-- GFM-TOC -->


# 必要条件

<div align="center"> <img src="pics/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

# 处理方法

主要有以下三种方法：

- 死锁检测与死锁恢复
- 死锁预防

```
破坏死锁成立的必要条件
```

- 死锁避免

# 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

## 1. 进程拥有一个资源

<div align="center"> <img src="pics/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>

上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，**它满足了环路等待条件，因此会发生死锁。**

进程拥有一个资源算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

### 单个资源的银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

<div align="center"> <img src="pics/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

## 2. 进程拥有多个资源

> 多个资源银行家算法

> > 如果未找到可以被标记的进程，判断请求会进入不安全状态，拒绝请求

<div align="center"> <img src="pics/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>

上图中，P<sub>1</sub>、P<sub>2</sub>、P<sub>3</sub> 三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量（第一行P<sub>1</sub>、第二行P<sub>2</sub>...）
- R 矩阵：每个进程请求的资源数量

1. 进程 P<sub>1</sub> 和 P<sub>2</sub> 请求的资源无法满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行。

2. 执行后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行。
3. 执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，算法执行中有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，**并转回 1。**
3. 如果没有这样一个进程，算法终止。

## 3. 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

如果一个状态不是安全的，需要拒绝进入这个状态。

