## 快速开始

- [`[基础]` 字符匹配](#字符匹配)
- [`[基础]` 位置匹配](#位置匹配)
- [`[面试]` 经典](#经典)

- [一 字符匹配](#一-字符匹配)
  - [1.1 两种模糊匹配](#_11-两种模糊匹配)
  - [1.2 贪婪和惰性匹配](#_12-贪婪和惰性匹配)
  - [1.2 分枝条件](#_12-分枝条件)
- [二 位置匹配](#二-位置匹配)
  - [2.1 Linux 简介](#_21-linux简介)
- [三 括号的作用](#三-括号的作用)
  - [3.1 Linux 文件系统简介](#_31-linux文件系统简介)
  - [3.2 文件类型与目录结构](#_32-文件类型与目录结构)
- [四 Linux 基本命令](#四-linux基本命令)
  - [4.1 目录切换命令](#_41-目录切换命令)
  - [4.2 目录的操作命令（增删改查）](#_42-目录的操作命令增删改查)
  - [4.3 文件的操作命令（增删改查）](#_43-文件的操作命令增删改查)
  - [4.4 压缩文件的操作命令](#_44-压缩文件的操作命令)
  - [4.5 Linux 的权限命令](#_45-linux的权限命令)
  - [4.6 Linux 用户管理](#_46-linux用户管理)
  - [4.7 Linux 系统用户组的管理](#_47-linux系统用户组的管理)
  - [4.8 其他常用命令](#_48-其他常用命令)
- [参考](#参考)

正则表达式是匹配模式。要么匹配字符，要么匹配位置。

## 一 字符匹配

### 1.1 两种模糊匹配

正则表达式之所以强大在于其能实现模糊匹配。而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。

**纵向模糊匹配**

可以想象具体到某一位字符是由 `[]` 旋转90度后可以滑动选择。

- 字符类

    - `-` 连接 ASCII 相邻字符
    - `^`：反义

```
很简单，你只需要在方括号里列出它们就行了

[0-9]代表的含意与\d就是完全一致的：一位数字
[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）

连字符拥有特殊用途（省略和简写），匹配“a”、“-”、“z”这三者中任意一个字符，需要转义[a\-z]
```

- 元字符

语法 | 说明
------------ | -------------
`.` | 匹配除换行符、回车符以外的任意字符（`[^\n\r]`）
\w | 匹配字母或数字或下划线或汉字（`[0-9a-zA-Z_]`）
\s | 匹配任意的空白符，包括空格、制表符、换行符、回车符、换页符（`[' ' \t\n\r\f]`）
\d | 匹配数字

```
java 与 JavaScript 中的标识符为 (\w\$)* 对吗？
错误：因为 \w\$ 匹配了两个字符而非一个具体字符。

=> [0-9a-zA-Z_$]* √
```

- 反义

语法 | 说明
------------ | -------------
\W | 匹配任意不是字母，数字，下划线，汉字的字符
\S | 匹配任意不是空白符的字符
\D | 匹配任意非数字的字符
[^x] | 匹配除了x以外的任意字符

```
匹配任意字符：[^]
```

**横向模糊匹配**

一个正则可匹配的字符串的长度不是固定的

语法 | 说明
------------ | -------------
* | 重复零次或更多次
+ | 重复一次或更多次
? | 重复零次或一次
{n} | 重复n次
{n,} | 重复n次或更多次
{n,m} | 重复n到m次
	

### 1.2 贪婪和惰性匹配

**贪婪匹配**

当正则表达式中包含接受重复的限定符时，通常的行为是（**整个表达式能得到匹配的前提下**）匹配尽可能多的字符。

以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。

```js
var str = "  foobar   ";
function trim(str) {
	return str.replace(/^\s*(.*)\s*$/g, "$1");
}
// => "foobar   "
```

**惰性匹配**

有时，我们更需要匹配尽可能少的字符。我们只需要在重复限定符后面加上一个 `?`，**（整个匹配成功的前提下）**使用最少的重复。

使用`*?`匹配，不然会匹配最后一个空格之前的所有空格的。

```js
var str = "  foobar   ";
function trim(str) {
	return str.replace(/^\s*(.*?)\s*$/g, "$1");
}
// => "foobar"
```

<div align="center">  <img src="惰性匹配优先级" width="75%" height="75%" /></div><br>

### 1.3 分枝条件

一个模式可以实现横向和纵向模糊匹配。而分支条件可以支持多个子模式任选其一。

使用管道符`|`分割。要注意分支顺序。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果某个分支匹配成功，就会忽略其他分支条件。

```js
// regex1 只会匹配5位的邮编(以及9位邮编的前5位)
var regex = /\d{5}-\d{4}|\d{5}/ 
var regex1 = /\d{5}|\d{5}-\d{4}/ 

var zipCode = '94107-4067'
console.log( regex1.match(zipCode) ); 
// => 94107
```

## 二 位置匹配

正则表达式是匹配模式，要么匹配字符，要么匹配位置。

### 2.1 如何匹配位置?

**位置：相邻字符之间的位置。对于其理解，我们可以理解为空字符""**

<div align="center">  <img src="位置" width="75%" height="75%" /></div><br>

```js
// "hello"字符串等价于如下的形式
"hello" == "" + "h" + "" + "e" + "" + "l" + "" + "l" + "o" + "";
```

因此，把`/^hello$/`写成`/^^hello$$$/`，是没有任何问题的

```js
var res = /^^hello$$$/.test("hello");
console.log(res); // true
```

语法 | 说明
------------ | -------------
^ | 匹配字符串的开始
$ | 匹配字符串的结束
\b | 匹配单词的开始或结束
\B | 匹配不是单词开头或结束的位置
(?=exp) | 匹配exp前面的位置
(?!exp) | 匹配后面跟的不是exp的位置

**2.1.1 `\b`和`\B`**

`\b`为单词边界位置，具体就是`\w`和`\W`之间的位置（包括`\w`和`^、$`）

```js
var res = "[JS] Lesson_01.docx".replace(/\b/g, '#');
console.log(res); 
// => "[#JS#] #Lesson_01#.#docx#"
```

`\B`就是`\b`的反面。

```js
var res = "[JS] Lesson_01.docx".replace(/\B/g, '#');
console.log(res); 
// => "#[J#S]# L#e#s#s#o#n#_#0#1.d#o#c#x"
```

**2.1.2 `(?=exp)`和`(?!exp)`**

`(?=exp)`中p是一个子模式，即p前面的位置。 <- 正向先行断言（positive lookbehind）

```js
var res = "hello".replace(/(?=l)/g, '#');
console.log(res); 
// => "he#l#lo"
```

`(?!exp)`就是`(?=exp)`的反面。 <- 负向先行断言（negative lookbehind）

```js
var res = "hello".replace(/(?!l)/g, '#');
console.log(res); 
// => "#h#ell#o#"
```

## 举个栗子：数字千分位分隔符表示法

比如把"12345678"，变成"12,345,678"。

1. 弄出最后一个逗号 ","，使用`replace(/(?=\d{3}$)/g, ',')`就可以做到。

2. 弄出所有逗号","，要求后边3个数字一组，也就是`\d{3}`至少出现一次。可以使用`replace(/(?=(\d{3})+$)/g, ',')`

```js
// 我们会发现问题
var res = "123456789".replace(/(?=(\d{3})+$)/g, ',')
console.log(res); 
// => ",123,456,789"
```

3. 我们需要匹配得到的这个位置不能使开头。匹配开头使用的是`^`，那么我们如何才能不匹配开头呢？`(?!^)`可以使这个位置不是开头（开头之前的位置也是开头）。

## 三 括号的作用

### 3.1 分组和分支结构

- 分组

```
/a+/ 可以匹配连续出现的 "a"。而要匹配连续出现的 "ab" 时，需要使用 /(ab)+/
```

- 分支结构

```
(p1|p2) - 提供了子表达式的所有可能
```

### 3.2 引用分组-API

**如果括号嵌套了，以左（开括号）为准**

假如我们需要匹配格式为 yyyy-mm-dd 的日期格式：

```js
// 为什么不写为 /\d{4}-\d{2}-\d{2}/ 呢？
var regex = /(\d{4})-(\d{2})-(\d{2})/;
```

**提取数据**

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
string.match(regex);
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

1. `str.match(regexp)`

参数：

- 使用 `/g` 标志

```
返回值：正则匹配结果（Array），但不会返回捕获组
```

- 未使用 `/g` 标志 

```
返回值：仅返回第一个完整匹配（Array）及其相关的捕获组

附加属性
1. groups: 命名捕获组 || undefined
2. index: 匹配结果的开始位置
3. input: 搜索的字符串
```

2. `regexp.exec(str)`

3. 构造函数全局`$1-$9`属性

```js
RegExp.$1; // "2017"
RegExp.$2; // "06"
RegExp.$3; // "12"
```


**替换**

yyyy-mm-dd 格式，替换为 mm/dd/yyyy

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
string.replace(regex, "$2/$3/$1");// => "06/12/2017"
```

`replace()` 中第二个参数等价于：

```js
string.replace(regex, function() {
	return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
```

也等价于：

```js
string.replace(regex, function(match, year, month, day) {
	return month + "/" + day + "/" + year;
});
```

### 3.3 反向引用-正则

**反向引用是引用前面的分组**

如果我们想要匹配 2016-06-12、2016/06/12 与 2016.06.12

```js
// var string = "2016-06/12"; - 会匹配到前后不一致的情况
var regex = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/;
```

反向引用可以帮我们实现前后一致的需求。

```js
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
```

`\1`表示的引用之前的那个分组`(-|\/|\.)`。不管它匹配到什么（比如`-`），`\1`都匹配那个同样的具体某个字符。`\2、\3`分别指代第二个和第三个分组。

### 3.3 非捕获分组

- **捕获分组**

```
捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。
```

- **非捕获分组`(?:p)`**

```
既不在API里引用，也不在正则里反向引用
```

```js
var regex = /(?:ab)+/g;
var string = "ab abbb abab";
string.match(regex); // => ["ab", "ab", "abab"]
```

## 参考

[正则表达式字符匹配攻略](https://juejin.im/post/5965943ff265da6c30653879#heading-1)

[C标准中的空白字符](https://blog.csdn.net/boyinnju/article/details/6877087)

var regexp = '111124gf'.replace(/^(?!\d+)$/g, '#');
// 无法匹配到这样的位置

console.log(regexp)


!!!字符和位置混合匹配的问题

不能

var regexp = '111124gf'.replace(/^.+(?!\d+).+$/g, '#');

(?!^[0-9]{6,12}$)ABC 可以成功匹配 "ABC"

正则判断是够包含某一字符：
var reg = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;
var reg = /^.*\d[0-9A-Za-z]{5,11}$|^[0-9A-Za-z]{5,11}.*\d$/; // 还差一个中间位置，但无法写出 "\d" 位置


111124#g#f#
位置与字符同时进行匹配？只能先匹配了位置，再确定字符。

css直接去看 Element 样式
