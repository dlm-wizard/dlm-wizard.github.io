<!-- GFM-TOC -->

- [数制与编码](#数制与编码)
- [无符号数](#无符号数)
- [有符号数](#有符号数)
  - [1. 定点数](#1-定点数)
  - [2. 原码](#2-原码)
  - [3. 补码](#3-补码)
  - [4. 反码](#4-区别)
  - [5. 移码](#5-移码)
- [移位运算](#移位运算)

# 数制与编码

## 1. 除基取余法

> 除基取余法应该是把这个秦九韶算法倒过来的过程

```java
// 加法 4 次 + 乘法 10 次
f(x) = 3x^4 + 4x^3 + 2x^2 + 5x + 6
```

x 为几进制数，就除 x 取余，这样就可以得到各位的数值。

```java
// 秦九韶算法
// 加法 4 次 + 乘法 4 次
f(x) = 3x^4 + 4x^3 + 2x^2 + 5x + 6
     = (3x^3 + 4x^2 + 2x^1 + 5)x + 6
     ...
     = (((3*x + 4)x + 2)x + 5)x + 6
```

# 无符号数

没有符号位，相当于绝对值。表示 2^n 种**不同的状态。**

n 位的无符号数表示范围：`0 ~ 2^n - 1`

# 有符号数

## 1. 定点数

<div align="center"> <img src="定点小数"/> </div><br>

```bash
n 指的是数值部分的位数，不包括符号位

# n 位尾数
定点整数表示范围：-(2^n - 1) ~ 2^n - 1
定点小数表示范围：-(1- 2^-n) ~ 1- 2^-n
```

## 2. 原码

> 字长为 n+! 位原码表示范围与 n 位尾数的定点数相同

**若字长为 n+1, 则原码表示范围为 -(2^n - 1) <= x <= 2^n - 1（±0）**

```bash
原码就是数值部分有 n 位的定点数 + 符号位 # 字长为 n+1 位

[x]原 = 1.1101 # 十进制真值为 -0.8125
[x]原 = 1.1101 000 # 假设计算机字长为 8 位
11101000 # 机器数
```

假设用原码来进行运算的话，我们需要根据符号位改变运算规则

```bash
0 0001100 + 1 0001100
    0 0001100
-   0 0001100 # 根据符号位调整，进行相应的定点数运算
----------------------------
    0 0000000
```

## 3. 补码

mod: 取余运算

<div align="center"> <img src="补码"/> </div><br>

**若字长为 n+1, 则补码表示范围为 -2^n ≤ x ≤ 2^n - 1（比原码多表示 -2^n）。栗如，字长为 9 位（最高位是符号位），补码 1, 0000 0000 的原码表示为 1, 1 0000 0000**

```bash
# 一个 n 位字长的机器码，它的模就是 2^n
 14
-14 # 【[x]补 = mod - |x|, 0≥ x ≥ -2^n】【mod=2^n+1】

      0000 1110 # 8 位字长
-   1,0000 0000 - 0000 1110 # 取模过程见 负数原码 -> 补码
=     0000 1100
+     1111 0010
----------------------------
    1,0000 0000
mod 1,0000 0000 = 0

# mod 运算为什么比 根据符号位调整，进行定点数减法运算更简单？

```

得到一种新的编码方式（补码）

```bash
纯小数的模等于 2
-0.1001 # 【[x]补 = mod - |x|, 0 ≥ x ≥ -1】【mod=2】
```

- 正数：与原码相同
- 负数：数值位取反再加 1

```bash
# 【[x]补 = mod - |x|】=> 1.符号位不变
    1,0000 0000
=   0,0000 0001 + 0,1111 1111 # 机器字长为 8 位
===========2.取反===============3.加1=======
(0,1111 1111 - 0000 1110) + 0,0000 0001
```

## 4. 反码

```
由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等。在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小
```

## 5. 移码

真值与机器数对应关系不直观。负数机器数较大，而真值较小。移码就是用来解决这个问题的。

机器数 = 2^n + [x]移;

<div align="center"> <img src="移码"/> </div><br>

# 移位运算

## 1. 无符号数

逻辑移位，移动时添 0。
