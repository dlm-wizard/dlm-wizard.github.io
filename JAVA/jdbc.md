<!-- GFM-TOC -->
* [一、概览](#一概览)
    * [使用JDBC](#使用JDBC)
* [二、PreparedStatement对象](#二PreparedStatement对象)
    * [占位符](#占位符)
    * [批处理](#批处理)
    * [大文本数据&&二进制数据](#大文本数据&&二进制数据)
    * [获取数据库自增列](#获取数据库自增列)
    * [调用数据库存储过程](#调用数据库存储过程)
* [三、源码分析](#三源码分析)
    * [事务](#事务)
    * [Vector](#vector)
* [参考资料](#参考资料)
<!-- GFM-TOC -->


# 一、概览

JDBC（Java Data Base Connectivity）是可以执行 sql 语句的 java api。本来我们需要根据市面上不同的数据库学习不同的 API，sun 公司为了简化这个操作，定义了 JDBC API【接口】。sun公司只是提供了JDBC API【接口】，数据库厂商负责实现。对于我们来说，操作数据库都是在JDBC API【接口】上，使用不同的数据库，只要用数据库厂商提供的数据库驱动程序即可。

## 使用JDBC

1.注册驱动

```java
// DriverManager.registerDriver(new com.mysql.jdbc.Driver());
Class.forName(driverClass).newInstance();
```

2.建立连接

```java

Connection connection = DriverManager.getConnection(url, user, password);
```

3.使用 JDBC Statement 对象执行 SQL

```java
Statement statement = connection.createStatement();

ResultSet resultSet = statement.executeQuery("sql here");
statement.executeUpdate("sql here");
```

4.关闭连接

```java
// it is a good idea to release
// resources in a finally{} block
// in reverse-order of their creation
// if they are no-longer needed
resultSet.close();
statement.close();
connection.close();
```

# 二、PreparedStatement对象

预编译 sql 语句并存储在 PreparedStatement 对象中。`This object can then be used to efficiently execute this statement multiple times.`

防止 sql 注入

## 占位符

```java
// 通过占位符简化 sql 编写
// String sql = "SELECT * FROM users WHERE id = " + id;
String sql = "SELECT * FROM users WHERE id = ?";

// @param parameterIndex the first parameter is 1, the second is 2, ...
// @param x the parameter value
preparedStatement.setString(parameterIndex, x);
```

## 批处理

```java
// Statement 实现批处理
String sql1 = "SELECT * FROM users WHERE id = " + id;
String sql2 = "SELECT * FROM users WHERE age = " + age;

// 添加批处理 sql
statement.addBatch(sql1);
statement.addBatch(sql2);

// 执行批处理
statement.executeBatch();

// 清空批处理 sql
statement.clearBatch();
```

```java
// PreparedStatement 实现批处理
String sql = "SELECT * FROM users WHERE id = ?";

for (int i = 0; i < 256; i++) {
    preparedStatement.setInt(1, i);
    preparedStatement.addBatch(sql);

    if (i >> 7 == 1) {
        preparedStatement.executeBatch();
        // 清空批处理 sql
        // 如果数据量太大，所有数据存入批处理，内存肯定溢出
        preparedStatement.clearBatch();
    }
}
// 分批次执行批处理
preparedStatement.executeBatch();
preparedStatement.clearBatch();
```

## 大文本数据&&二进制数据

Mysql 中使用 TEXT 替代 CLOB 存储大文本。

[JDBC连接Oracle数据库去操作大文本数据和二进制数据](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483745&idx=3&sn=26cc7194bca0f460f900176156b1795d&chksm=ebd74060dca0c97674f0ff43d7d9d831f7c773d8e5675e5d488356f5f3eb14283bd3be0faaba#rd)

```java
// 插入大文本数据
string sql = "INSERT INTO users (BIGTEXT) VALUES(?)";
String path = JdbcUtil.class.getClassLoader().getResource("text").getPath();
FileReader fileReader = new FileReader(new File(path));
preparedStatement.setCharacterStream(1, fileReader);

preparedStatement.executeUpdate()
```

```java
// 读取大文本数据
ResultSet resultSet = preparedStatement.executeQuery();
if (resultSet.next()) {
    Reader reader = resultSet.getCharacterStream("bigTest");
    FileWriter fileWriter = new FileWriter("text.txt");
    
    char[] c = new char[1024];

    while (int len = reader.read(c) != -1) {
        fileWriter.write(c, 0, len);
        fileWriter.flush();
    }
    fileWriter.close();
    reader.close();
}
```

## 获取数据库自增列

读注释的时候仔细一些

> @param autoGeneratedKeys a constant indicating whether auto-generated
> keys should be made available for retrieval using the method
> `<code>`getGeneratedKeys`</code>`; one of the following constants:
> `<code>`Statement.RETURN_GENERATED_KEYS`</code>` or
> `<code>`Statement.NO_GENERATED_KEYS`</code>`

[PreparedStatement with Statement.RETURN_GENERATED_KEYS](https://stackoverflow.com/questions/4224228/preparedstatement-with-statement-return-generated-keys)

## 调用数据库存储过程

```java
/*
    delimiter $$
        CREATE PROCEDURE helloWorld(
            INOUT printContent varchar(10)
        )
        BEGIN
            SELECT printContent FROM DUAL;
        END $$
    delimiter ;
*/
Connection conn = jdbcUtils.getConnection();
CallableStatement callable = conn.prepareCall({call helloWorld(?)});

callable.setString(1, "helloWorld");
// The JDBC type specified by <code>sqlType</code> for an OUT
// parameter determines the Java type that must be used
// in the <code>get</code> method to read the value of that parameter.
callable.registerOutparamter(1, Types.VARCHAR);
callable.execute();

String res = callable.getString(2);

try {
    callable.close();
    conn.close();
} catch (SQLException e) {
    e.printStackTrace();
}
```

# 三、

## 事务

AUTOCOMMIT：MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。

- 丢失修改
- 读脏数据
- 不可重复读
- 幻影读

```java
try {
    // If a connection is in auto-commit mode, then all its SQL
    // statements will be executed and committed as individual
    // transactions.  Otherwise, its SQL statements are grouped into
    // the method <code>commit</code> or the method <code>rollback</code>.
    conn.setAutoCommit(false);

    // 账号ACCOUNT_1向账号ACCOUNT_2转账
    String sql1 = "UPDATE ACCOUNT_1 SET MONEY = MONEY - 500"
    String sql2 = "UPDATE ACCOUNT_2 SET MONEY = MONEY + 500"

    PreparedStatement preparedStatement = conn.prepareStatement(sql1);
    preparedStatement.executeUpdate();

    // 原子性（Atomicity）
    // 同一 session 连接所有操作要么全部提交成功，要么全部失败回滚。
    int e = 0/0;

    PreparedStatement preparedStatement = conn.prepareStatement(sql1);
    preparedStatement.executeUpdate();

    conn.commit();
    conn.setAutoCommit(true);  
} catch(SQLException e) {
    try {
        // 全部操作失败，显示事务回滚
        conn.rollback();
        conn.setAutoCommit(true);  
    } catch(SQLException e) {
        e.printStackTrace();
    }
} 
```

## 元数据

**create && update && delete**

```java
public static void update(sql, Object[] objects) {
    try {
        PreparedStatement prep = conn.prepareStatement(sql);

        // 根据 Object[] 设置 sql 占位符
        for (int i = 0; i < objects.length; i++) {
            prep.setObject(i+1, objects[i]);
        }

        prep.executeUpdate();
    } catch(SQLException e) {
        e.printStackTrace();
    }
}
```

**read**

```java
/**
 * 策略模式
 * 因为不确定对查询语句的结果集进行什么操作（封装为 bean、list...）
 * 我们可以定义一个接口，让调用者把接口的实现类传递进来
 * 这样接口调用的方法就是调用者传递进来实现类的方法
 */
public static Object query (String sql, Object[] objects, ResultSetHandler rsh) {
    try {
        PrepareStatement perp = conn.prepareStatement(sql);

        for (int i = 0; i < objects.length; i++) {
            prep.setObject(i+1, objects[i]);
        }

        ResultSet res = prep.executeQuery();
        // 对结果集进行操作
        return rsh.hanlder(res);
    }
}
```

- 接口

```java
public interface ResultSetHandler {
    Object hanlder(ResultSet resSet);
}
```

- 实现类

```java
public class BeanHandler implements ResultSetHandler {
    private Class clazz;

    public BeanHandler(Class clazz) {
        this.clazz = clazz;
    }

    @Override
    public Object hanlder(ResultSet resSet) {
        try {
            //创建传进对象的实例化
            Object bean = clazz.newInstance();

            if (resSet.next()) {

                ResultSetMetaData resultSetMetaData = resSet.getMetaData();

                for (int i = 0; i < resultSetMetaData.getColumnCount(); i++) {

                    //获取到每列的列名
                    String colName = resultSetMetaData.getColName(i+1);

                    //获取到每列的数据
                    String colData = resSet.getString(i+1);

                    //设置Bean属性
                    Field field = clazz.getDeclaredField(colName);
                    field.setAccessible(true);
                    field.set(bean, colData);
                }

                return bean;
            }
}
```

# 数据库连接池

数据库连接池就是提供连接的。

- 数据库连接的建立和关闭是非常消耗资源的

- 频繁的打开、关闭连接造成系统性能低下

编写连接池

1. 编写连接池需要实现 java.sql.DataSource 接口

2. 创建批量的 Connection 用 LinkedList 保存【池当然使用集合保存，链表增删性能较好】

3. 重新实现 getConnection【在 LinkedList 中取一个 Connection 返回给用户】

4. Connection 类 close 方法将连接放回连接池【不需要关闭数据库连接】

```java
private static LinkedList<Connection> conns = new LinkedList<>();

private static String driverClass;
private static String url;
private static String user;
private static String password;

// 仅需要获取一次连接
static {
    Properties properties = new Properties();
    // 读取配置文件
    InputStream inputStream = JdbcConnectionPool.class.getClassLoader().getResourceAsStream("application.properties");

    try {
        properties.load(inputStream);
    } catch (IOException e) {
        e.printStackTrace();
    }

    driverClass = properties.getProperty("driverClassName");
    url = properties.getProperty("url");
    user = properties.getProperty("user.name");
    password = properties.getProperty("password");

    try {
        Class.forName(driverClass);

        for (int i = 0; i < 10; i++) {
            Connection conn = DriverManager.getConnection(url, user, password);
            conns.add(conn);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static Connection getConnection() throws SQLException {
    return conns.size() > 0 ? conns.removeFirst() : null;
}
```

现在已经实现了前三步，对于最后一步来说，有下述 3 种解决思路

- 

```
Connection是通过数据库驱动加载的，保存了数据的信息。写一个子类Connection，new出对象，子类的Connction无法直接继承父类的数据信息，也就是说子类的Connection是无法连接数据库的，更别谈覆盖close()方法了。
```

- 

```
写一个Connection包装类（实现 && 方法太多）
1. 写一个类，实现与被增强对象的相同接口【Connection接口】
2. 定义一个变量，指向被增强的对象
3. 定义构造方法，接收被增强对象
4. 覆盖想增强的方法
5. 对于不想增强的方法，直接调用被增强对象的方法
```

- 用动态代理，返回一个代理对象出去，拦截close()方法的调用，对close()增强

```java
public static Connection getConnection() throws SQLException {

    // 池的大小大于0
    if (conns.size() > 0) {
        final Connection conn = conns.removeFirst();

        return (Connection) Proxy.newProxyInstance(JdbcConnectionPool.class.getClassLoader(), conn.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                //
                if (!method.getName().equals("close")) {
                    method.invoke(conn, args);
                } else  {
                    // 调用 close 方法关闭连接
                    conns.add(conn);
                }
                return null;
            }
        });
    }
    return null;
}
```


## DbUtils框架

## 分页

# 参考资料

[在Java学习中，JDBC应该学到什么程度？](https://www.zhihu.com/question/271533176)

[主流Java数据库连接池比较及前瞻](https://cloud.tencent.com/developer/article/1171153)

